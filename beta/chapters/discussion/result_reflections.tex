\section{Result Analysis}

The common operator tests do not contain any surprises other than that Python addition is faster than its other operator tests. The reason is because that code uses a built-in \textit{sum} function \cite{PythonSum} (see Figure \ref{fig:addition_test}) while the others use the \textit{reduce} function \cite{PythonReduce}.

Many of the slow execution results from Python derives from a couple of things. Firstly, Python is an interpreted language which means it suffers from a rather significant performance penalty from the start, this can be seen in Figure \ref{fig:insertion_sort_all_native} where Python gets heavily outperformed by the other two languages, both of which are compiled languages. Also, in the .NET environment the Python code is run by a ScriptEngine, adding another layer of interpretation. This is also reflected in the language overhead test in Section \ref{subsec:language_overhead}. Good Python performance seem dependent on using the built-in functions of the language (since these are written in C), for instance a 3-4 time speed increase can be seen using the built in sort function \textit{Tim Sort} \cite{PythonSort} (a hybrid algorithm using a mix of insertion sort and merge sort), see Figure \ref{fig:tim_sort}.

Java outperforms C\# on every test when run in the native environment. An even further speed increase could be achieved by adding the \textit{-server} tag to the JVM making Java the fastest language by far in the native comparison tests.

The memory consumption of Merge Sort with 10'000 elements is about the same as with Insertion Sort. It would seem that this amount of elements is too small to have an impact on the amount of memory consumed. One would expect Merge Sort to consume significantly more memory, but the data obtained seem to be a reflection of a static cost.

Java is the least conservative language in relation to memory consumption. This can be seen in Figure \ref{fig:merge_sort_memory_all}. It is, in fact, so memory hungry that the GC gets invoked every other run. It also happens to be the fastest native language regardless of the number of elements that need to be sorted; both of these tendencies are also confirmed by \cite{Benchmark} \cite{Benchmark2}, however, keep in mind that these articles concerns native Java and not CIL compiled byte code in .NET. The memory consumption could either be a result of \textit{javac} producing memory inefficient byte code or IKVM compiling the byte-code to CIL inefficiently.

