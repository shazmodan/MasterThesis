\section{Result Analysis}

The common operator tests doesn't contain any surprises except that Python addition is faster than its other operator tests. The reason is because that particular code uses a built-in \textit{sum} function (see Figure \ref{fig:addition_test}), while the others use the \textit{reduce} function.

Many of the slow execution results from Python derives from a couple of things. Firstly, Python is an interpreted language which means it suffers from a rather significant performance penalty from the start, this can be seen in Figure \ref{fig:insertion_sort_all_native} where Python gets heavily outperformed by the other two languages, both of which are compiled languages. Also, in the .NET environment the Python code is run by a ScriptEngine, adding another layer of interpretation. This is also reflected in the language overhead test in Section \ref{subsec:language_overhead}. Good Python performance seem very dependant on using the built-in functions of the language (since these are written in C), for instance a 3-4 time speed increase can be seen using the built in sort function \textit{Tim Sort} (a hybrid algorithm using a mix of insertion sort and merge sort), see Figure \ref{fig:tim_sort}.

Java outperforms C\# on every test when run in the native environment. An even further speed increase could be achieved by adding the \textit{-server} tag to the JVM making Java the fastest language by far in these tests.

The memory consumption of Merge Sort with 10'000 elements is about the same as with Insertion Sort. It would seem that this amount of elements is too small to have an impact on the amount of memory consumed, and the data obtained is simply a reflection of a static cost.

Java is the least conservative language in relation to memory consumption. This can be seen in Figure \ref{fig:merge_sort_memory_all}. It's in fact so memory hungry that the GC gets invoked every other run. It also happens to be the fastest native language regardless of the number of elements that needs to be sorted, both of these tendencies are also confirmed by \cite{Benchmark} \cite{Benchmark2}, however keep in mind that these articles concerns native Java and not CIL compiled byte code in .NET. The memory consumption could either be a result of \textit{javac} producing memory inefficient byte code or of IKVM compiling the byte-code to CIL inefficiently.

