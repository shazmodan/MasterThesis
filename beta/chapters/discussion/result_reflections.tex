\section{Result Analysis}

The common operator tests do not contain any surprises other than that Python addition is faster than its other operator tests. The reason is because the addition code uses a built-in \textit{sum} function \cite{PythonSum} (see Figure \ref{fig:addition_test}) while the others use the \textit{reduce} function \cite{PythonReduce}. The sum function applies a binary add between the numbers in the list while the reduce function does a function call for whatever operator that was passed as an argument. The overhead of all the function calls explains the reduce function's performance hit.

Many of the slow execution results from Python derives from a couple of things. Firstly, Python is an interpreted language which means it suffers from a rather significant performance penalty from the start, this can be seen in Figure \ref{fig:native_insertion_sort} where Python gets heavily outperformed by the other two languages, both of which are compiled languages. Also, in the .NET environment the Python code is run by a ScriptEngine, adding another layer of interpretation. This is also reflected in the language overhead test in Section \ref{subsec:language_overhead}. Good Python performance seem dependent on using the built-in functions of the language (since these are written in C). A very significant performance increase could have been accomplished using the built in sort function \textit{Tim Sort} \cite{PythonSort} (a hybrid algorithm using a mix of Insertion sort and Merge sort). Using this algorithm for sorting in Python however, would not have been fair to the other languages since they use only the simple Insertion sort and Merge sort. The Timsort algorithm is also one of the best sorting algorithms ever written and is worthy of its \textit{own} scientific paper.

Python is the least conservative language in relation to memory consumption. This can be seen in Figure \ref{fig:net_merge_sort_memory}. This might be due to Python doing strange things under the hood such as handling integers as longs thus consuming more memory \cite{PythonInteger}.

A very significant result is shown in Table \ref{table:scaling_factors}. Here we can see that the scaling factor needed for Java can be obtained. It would seem that the scaling factor would be between 1.27 and 1.31 giving an average of 1.29. This is impactful to anyone who wish to convert any Java project to a .NET project through the use of ikvmc. The memory seem to scale equally well with Java and C\#, see Figure \ref{fig:net_merge_sort_memory}. A scaling factor for Python cannot be obtained from these results since they are too varying. This makes the support for Python strictly usefull for code inspection purposes.
