\section{Difficulties and limitations}

\subsection{Security}
Executing unknown code can be dangerous for several reasons, the code might alter the core program or even do damage to the computer. Thus it was necessary to avert this danger by running the code in a safe and secure sandboxed environment. In .NET this is handled through the use of AppDomains which act as a layer of isolation between applications (ref http://msdn.microsoft.com/en-us/library/cxk374d9.aspx). AppDomains make it possible to protect the core application from malicious code and exceptions that might occur during execution of the unknown code. This protection comes at the cost of performance since AppDomains are able to load assemblies but cannot unload them. To get rid of a loaded assembly the entire AppDomain must be unloaded, which is the case with each new submission. CELINE creates a new AppDomain for each submission and then uses proxy objects called ``Marshals'' (ref http://msdn.microsoft.com/en-us/library/aa720494(v=vs.71).aspx) to enable communication between the core-AppDomain and the untrusted-AppDomain, in order to get the output that the unknown code produced.

There is an exception to the rule about AppDomains being safe from each other. That is when the code that is executing in the untrusted-AppDomain generates a stack overflow exception. This exception will travel back into its parents AppDomain (in this case the core-AppDomain) since it's no longer possible to catch this exception as from .NET 2.0 and above. In order to avoid crashes caused by stack overflow exceptions the CES is instantiated with each new submission by the WCF Service.


\subsection{IronPython limitations} \label{subsec:ironpython_limitations}
IronPython does not have the same performance as the other languages for a number of reasons. The first reason is that it's 61.6\% slower on average than normal Python (version 2.7) (ref http://ironpython.codeplex.com/wikipage?title=IP27A1VsCPy27Perf). The startup time is also significantly slower since this language is scripted using a ScriptEngine which adds another layer of interpretation. It is however important to mention that IronPython does have the capability to compile the code into an assembly, but with a serious drawback, the assemblys methods and main entry point cannot be invoked like other assemblies since the MSIL is not CLS-compliant (ref http://msdn.microsoft.com/en-us/library/system.clscompliantattribute.aspx) and therefore cannot be directly accessed from other .NET languages (ref %https://github.com/IronLanguages/main/blob/master/Languages/IronPython/Public/Doc/dotnet-integration.rst#accessing-python-code-from-other-net-code). 


- IronPython limitation
- Python ScriptEngine thing

\subsection{White- and black-box testing}

- White-box testing and black-box testing


