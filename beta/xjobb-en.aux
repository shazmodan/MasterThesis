\relax 
\catcode`"\active
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\@writefile{toc}{\changetocdepth  {2}}
\select@language{swedish}
\@writefile{toc}{\select@language{swedish}}
\@writefile{lof}{\select@language{swedish}}
\@writefile{lot}{\select@language{swedish}}
\select@language{english}
\@writefile{toc}{\select@language{english}}
\@writefile{lof}{\select@language{english}}
\@writefile{lot}{\select@language{english}}
\select@language{swedish}
\@writefile{toc}{\select@language{swedish}}
\@writefile{lof}{\select@language{swedish}}
\@writefile{lot}{\select@language{swedish}}
\select@language{english}
\@writefile{toc}{\select@language{english}}
\@writefile{lof}{\select@language{english}}
\@writefile{lot}{\select@language{english}}
\@writefile{lof}{\addvspace {10pt}}
\@writefile{lot}{\addvspace {10pt}}
\@writefile{toc}{\contentsline {chapter}{\chapternumberline {1}Introduction}{1}{chapter.1}}
\@writefile{toc}{\contentsline {section}{\numberline {1.1}Problem Statement}{1}{section.1.1}}
\@writefile{toc}{\contentsline {section}{\numberline {1.2}Goal}{1}{section.1.2}}
\@writefile{toc}{\contentsline {section}{\numberline {1.3}About Valtech}{2}{section.1.3}}
\citation{Gradebot}
\citation{Suleman}
\citation{Hollingsworth}
\@writefile{lof}{\addvspace {10pt}}
\@writefile{lot}{\addvspace {10pt}}
\@writefile{toc}{\contentsline {chapter}{\chapternumberline {2}Background}{3}{chapter.2}}
\@writefile{toc}{\contentsline {section}{\numberline {2.1}What is Automatic Grading?}{3}{section.2.1}}
\citation{GenerationReview}
\citation{Gradebot}
\citation{GenerationReview}
\citation{Gradebot}
\citation{Suleman}
\citation{GenerationReview}
\citation{Kattis}
\citation{Amelung}
\citation{GradingScheme}
\@writefile{toc}{\contentsline {section}{\numberline {2.2}History}{4}{section.2.2}}
\@writefile{toc}{\contentsline {section}{\numberline {2.3}Today's Systems}{4}{section.2.3}}
\newlabel{sec:todays_systems}{{2.3}{4}{Today's Systems\relax }{section.2.3}{}}
\@writefile{lof}{\addvspace {10pt}}
\@writefile{lot}{\addvspace {10pt}}
\@writefile{toc}{\contentsline {chapter}{\chapternumberline {3}Method}{7}{chapter.3}}
\@writefile{toc}{\contentsline {section}{\numberline {3.1}System Description}{7}{section.3.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.1}{\ignorespaces Overview of CELINE.}}{7}{figure.3.1}}
\newlabel{fig:SystemOverview}{{3.1}{7}{Overview of CELINE}{figure.3.1}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1.1}The Web GUI}{8}{subsection.3.1.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.2}{\ignorespaces The start page of CELINE.}}{8}{figure.3.2}}
\newlabel{fig:celine_startpage}{{3.2}{8}{The start page of CELINE}{figure.3.2}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1.2}The Automatic Grading System}{8}{subsection.3.1.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.3}{\ignorespaces Code submission page.}}{9}{figure.3.3}}
\newlabel{fig:celine_submit}{{3.3}{9}{Code submission page}{figure.3.3}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1.3}System-User Feedback}{9}{subsection.3.1.3}}
\newlabel{subsec:status_codes}{{3.1.3}{9}{System-User Feedback\relax }{subsection.3.1.3}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.4}{\ignorespaces Common paths of problem flow in the AGS.}}{10}{figure.3.4}}
\newlabel{fig:flowchart}{{3.4}{10}{Common paths of problem flow in the AGS}{figure.3.4}{}}
\citation{MicrosoftCSharp}
\citation{CodeDomCompiler}
\citation{Javac}
\citation{JDK}
\citation{IKVMC}
\citation{IKVM.NET}
\citation{IronPython}
\citation{ApplicationDomains}
\citation{Marshals}
\citation{Suleman}
\@writefile{toc}{\contentsline {section}{\numberline {3.2}Supported Languages}{11}{section.3.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2.1}C\#}{11}{subsection.3.2.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2.2}Java}{11}{subsection.3.2.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2.3}Python}{11}{subsection.3.2.3}}
\@writefile{toc}{\contentsline {section}{\numberline {3.3}Difficulties and Limitations}{11}{section.3.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.3.1}Security}{11}{subsection.3.3.1}}
\newlabel{subsec:security}{{3.3.1}{11}{Security\relax }{subsection.3.3.1}{}}
\citation{StackOverflowException}
\citation{IronPythonPerformance}
\citation{CLSCompliant}
\citation{AccessingPythonCode}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.3.2}IronPython Limitations}{12}{subsection.3.3.2}}
\newlabel{subsec:ironpython_limitations}{{3.3.2}{12}{IronPython Limitations\relax }{subsection.3.3.2}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.3.3}White- and Black-box Testing}{12}{subsection.3.3.3}}
\newlabel{subsec:whitebox_blackbox}{{3.3.3}{12}{White- and Black-box Testing\relax }{subsection.3.3.3}{}}
\citation{Kattis}
\citation{Stopwatch}
\@writefile{lof}{\addvspace {10pt}}
\@writefile{lot}{\addvspace {10pt}}
\@writefile{toc}{\contentsline {chapter}{\chapternumberline {4}Testing Methodology}{13}{chapter.4}}
\@writefile{toc}{\contentsline {section}{\numberline {4.1}Aspects to Test}{13}{section.4.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1.1}Execution Speed}{13}{subsection.4.1.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1.2}Memory Consumption}{13}{subsection.4.1.2}}
\citation{BigO}
\@writefile{toc}{\contentsline {section}{\numberline {4.2}The Chosen Tests}{14}{section.4.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2.1}Language Overhead}{14}{subsection.4.2.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.1}{\ignorespaces C\# code for language overhead testing.}}{14}{figure.4.1}}
\newlabel{fig:language_overhead}{{4.1}{14}{C\# code for language overhead testing}{figure.4.1}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2.2}Common Operators}{14}{subsection.4.2.2}}
\citation{Insertionsort}
\@writefile{lof}{\contentsline {figure}{\numberline {4.2}{\ignorespaces Python code for testing the addition operation.}}{15}{figure.4.2}}
\newlabel{fig:addition_test}{{4.2}{15}{Python code for testing the addition operation}{figure.4.2}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2.3}Insertion Sort}{15}{subsection.4.2.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2.4}Merge Sort}{15}{subsection.4.2.4}}
\newlabel{subsec:merge_sort}{{4.2.4}{15}{Merge Sort\relax }{subsection.4.2.4}{}}
\citation{Mergesort}
\citation{ExecutionEngine}
\citation{Jit}
\@writefile{toc}{\contentsline {section}{\numberline {4.3}About Just-in-time compilation}{16}{section.4.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {4.3}{\ignorespaces Illustration of the Merge Sort algorithm using eight cards. The cards are subsequently divided up and then merged back together in sorted order.}}{17}{figure.4.3}}
\newlabel{fig:mergesort}{{4.3}{17}{Illustration of the Merge Sort algorithm using eight cards. The cards are subsequently divided up and then merged back together in sorted order}{figure.4.3}{}}
\@writefile{lof}{\addvspace {10pt}}
\@writefile{lot}{\addvspace {10pt}}
\@writefile{toc}{\contentsline {chapter}{\chapternumberline {5}Testing Results}{19}{chapter.5}}
\newlabel{chap:results}{{5}{19}{\@empty \relax }{chapter.5}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5.1}Testing Systems Specifications}{19}{section.5.1}}
\newlabel{sec:system_specs}{{5.1}{19}{Testing Systems Specifications\relax }{section.5.1}{}}
\@writefile{lot}{\contentsline {table}{\numberline {5.1}{\ignorespaces System specifications for the computers used.}}{19}{table.5.1}}
\newlabel{table:system_specs}{{5.1}{19}{System specifications for the computers used}{table.5.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5.2}Testing Procedure}{19}{section.5.2}}
\@writefile{toc}{\contentsline {section}{\numberline {5.3}Results}{20}{section.5.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.3.1}Native environments}{20}{subsection.5.3.1}}
\@writefile{toc}{\contentsline {subsubsection}{Addition Operator}{20}{section*.3}}
\@writefile{toc}{\contentsline {subsubsection}{Insertion Sort}{20}{section*.4}}
\@writefile{toc}{\contentsline {subsubsection}{Merge Sort}{20}{section*.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.3.2}.NET environment}{20}{subsection.5.3.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.1}{\ignorespaces This tests a language ability to sum 10 million elements. Lower is better. The results show that Java running in its native environment is the fastest of the three languages with 1.113 seconds. Python is the slowest of the three with a runtime of 5.278 seconds, even when using its native library functions to sum the elements, see \ref  {appendix:code_addition}.}}{21}{figure.5.1}}
\newlabel{fig:native_addition}{{5.1}{21}{This tests a language ability to sum 10 million elements. Lower is better. The results show that Java running in its native environment is the fastest of the three languages with 1.113 seconds. Python is the slowest of the three with a runtime of 5.278 seconds, even when using its native library functions to sum the elements, see \ref {appendix:code_addition}}{figure.5.1}{}}
\@writefile{toc}{\contentsline {subsubsection}{Language Overhead}{21}{section*.6}}
\newlabel{subsec:language_overhead}{{5.3.2}{21}{Language Overhead\relax }{section*.6}{}}
\@writefile{toc}{\contentsline {subsubsection}{Addition Operator}{21}{section*.7}}
\@writefile{toc}{\contentsline {subsubsection}{Insertion Sort}{21}{section*.8}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.2}{\ignorespaces This test uses the Insertion sort algorithm to sort 10'000 elements in ascending order. Lower is better. Note that the vertical axis is base 10 logarithmic. Java is the fastest with 0.015 seconds while Python is the slowest with 4.191 seconds. }}{22}{figure.5.2}}
\newlabel{fig:native_insertion_sort}{{5.2}{22}{This test uses the Insertion sort algorithm to sort 10'000 elements in ascending order. Lower is better. Note that the vertical axis is base 10 logarithmic. Java is the fastest with 0.015 seconds while Python is the slowest with 4.191 seconds}{figure.5.2}{}}
\@writefile{toc}{\contentsline {subsubsection}{Merge Sort}{22}{section*.9}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.3.3}The scaling factors}{22}{subsection.5.3.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.3}{\ignorespaces This test uses the Merge sort algorithm to sort one million elements in ascending order. Lower is better. Note that the vertical axis is base 10 logarithmic. Java is the fastest with 0.281 seconds while Python is the slowest with 12.358 seconds.}}{23}{figure.5.3}}
\newlabel{fig:native_merge_sort}{{5.3}{23}{This test uses the Merge sort algorithm to sort one million elements in ascending order. Lower is better. Note that the vertical axis is base 10 logarithmic. Java is the fastest with 0.281 seconds while Python is the slowest with 12.358 seconds}{figure.5.3}{}}
\@writefile{lot}{\contentsline {table}{\numberline {5.2}{\ignorespaces The overhead startup cost for each language when run in the .NET environment. Since C\# is the native language it has the lowest startup time with 0.014 seconds while Python has the longest with 1.006 seconds.}}{23}{table.5.2}}
\newlabel{table:language_overhead}{{5.2}{23}{The overhead startup cost for each language when run in the .NET environment. Since C\# is the native language it has the lowest startup time with 0.014 seconds while Python has the longest with 1.006 seconds}{table.5.2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.4}{\ignorespaces This tests a language ability to sum 10 million elements. Lower is better. The results show that C\# running in its native environment (.NET) is the fastest of the three languages with 2.909 seconds. Python is the slowest of the three with a runtime of 4.867 seconds.}}{24}{figure.5.4}}
\newlabel{fig:net_addition}{{5.4}{24}{This tests a language ability to sum 10 million elements. Lower is better. The results show that C\# running in its native environment (.NET) is the fastest of the three languages with 2.909 seconds. Python is the slowest of the three with a runtime of 4.867 seconds}{figure.5.4}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.5}{\ignorespaces This test is run in the .NET environment and uses the Insertion sort algorithm to sort 10'000 elements in ascending order. Lower is better. Note that the vertical axis is base 10 logarithmic. C\# is the fastest with 0.087 seconds. Java is a close second with 0.114 seconds. Python is the worst with 9.36 seconds.}}{25}{figure.5.5}}
\newlabel{fig:net_insertion_sort}{{5.5}{25}{This test is run in the .NET environment and uses the Insertion sort algorithm to sort 10'000 elements in ascending order. Lower is better. Note that the vertical axis is base 10 logarithmic. C\# is the fastest with 0.087 seconds. Java is a close second with 0.114 seconds. Python is the worst with 9.36 seconds}{figure.5.5}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.6}{\ignorespaces This test is run in the .NET environment and uses the Merge sort algorithm to sort one million elements in ascending order. A lower value is better. Note that the vertical axis is base 10 logarithmic. C\# is the fastest with 0.759 seconds. Java comes in second with 0.967 seconds. Python is the slowest with 71.663 seconds.}}{26}{figure.5.6}}
\newlabel{fig:net_merge_sort}{{5.6}{26}{This test is run in the .NET environment and uses the Merge sort algorithm to sort one million elements in ascending order. A lower value is better. Note that the vertical axis is base 10 logarithmic. C\# is the fastest with 0.759 seconds. Java comes in second with 0.967 seconds. Python is the slowest with 71.663 seconds}{figure.5.6}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.7}{\ignorespaces This test is run in the .NET environment and uses the Merge sort algorithm to sort one million elements in ascending order. A lower value is better. C\# and Java perform equally with 119MB and 120MB of memory used. Python performs the worst with 181MB of memory used. }}{27}{figure.5.7}}
\newlabel{fig:net_merge_sort_memory}{{5.7}{27}{This test is run in the .NET environment and uses the Merge sort algorithm to sort one million elements in ascending order. A lower value is better. C\# and Java perform equally with 119MB and 120MB of memory used. Python performs the worst with 181MB of memory used}{figure.5.7}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.8}{\ignorespaces This test is run in the .NET environment and uses the Merge sort algorithm to sort one million elements in ascending order. A lower value is better. C\# performs the best with 30\% processor usage, Java is a close second with 34\% and Python performs the worst with 39\%. }}{28}{figure.5.8}}
\newlabel{fig:net_merge_sort_processor}{{5.8}{28}{This test is run in the .NET environment and uses the Merge sort algorithm to sort one million elements in ascending order. A lower value is better. C\# performs the best with 30\% processor usage, Java is a close second with 34\% and Python performs the worst with 39\%}{figure.5.8}{}}
\@writefile{lot}{\contentsline {table}{\numberline {5.3}{\ignorespaces Add some text here...}}{28}{table.5.3}}
\newlabel{table:language_overhead}{{5.3}{28}{Add some text here..}{table.5.3}{}}
\citation{PythonSum}
\citation{PythonReduce}
\citation{PythonSort}
\citation{Benchmark}
\citation{Benchmark2}
\@writefile{lof}{\addvspace {10pt}}
\@writefile{lot}{\addvspace {10pt}}
\@writefile{toc}{\contentsline {chapter}{\chapternumberline {6}Discussion}{29}{chapter.6}}
\@writefile{toc}{\contentsline {section}{\numberline {6.1}Result Analysis}{29}{section.6.1}}
\citation{JavaScript.NET}
\citation{Jint}
\citation{Phalanger}
\citation{IronRuby}
\citation{Tiobe}
\@writefile{toc}{\contentsline {section}{\numberline {6.2}Conclusion}{30}{section.6.2}}
\@writefile{toc}{\contentsline {section}{\numberline {6.3}Future Work}{30}{section.6.3}}
\@writefile{toc}{\contentsline {chapter}{Bilagor}{30}{section*.10}}
\@writefile{lof}{\addvspace {10pt}}
\@writefile{lot}{\addvspace {10pt}}
\@writefile{toc}{\contentsline {chapter}{\chapternumberline {A}Code}{31}{appendix.A}}
\newlabel{appendix:code}{{A}{31}{\@empty \relax }{appendix.A}{}}
\@writefile{toc}{\contentsline {section}{\numberline {A.1}Language Overhead}{31}{section.A.1}}
\@writefile{toc}{\contentsline {section}{\numberline {A.2}Common Operators}{31}{section.A.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {A.2.1}Addition}{31}{subsection.A.2.1}}
\newlabel{appendix:code_addition}{{A.2.1}{31}{Addition\relax }{subsection.A.2.1}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {A.2.2}Subtraction}{32}{subsection.A.2.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {A.2.3}Multiplication}{33}{subsection.A.2.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {A.2.4}Division}{34}{subsection.A.2.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {A.2.5}Modulo}{35}{subsection.A.2.5}}
\@writefile{toc}{\contentsline {section}{\numberline {A.3}Insertion Sort}{36}{section.A.3}}
\@writefile{toc}{\contentsline {section}{\numberline {A.4}Merge Sort}{37}{section.A.4}}
\bibdata{chapters/mybib}
\bibcite{Gradebot}{1}
\bibcite{Suleman}{2}
\bibcite{Hollingsworth}{3}
\bibcite{GenerationReview}{4}
\bibcite{Kattis}{5}
\bibcite{Amelung}{6}
\bibcite{GradingScheme}{7}
\bibcite{MicrosoftCSharp}{8}
\bibcite{CodeDomCompiler}{9}
\bibcite{Javac}{10}
\@writefile{toc}{\contentsline {chapter}{Bibliography}{43}{section*.12}}
\bibcite{JDK}{11}
\bibcite{IKVMC}{12}
\bibcite{IKVM.NET}{13}
\bibcite{IronPython}{14}
\bibcite{ApplicationDomains}{15}
\bibcite{Marshals}{16}
\bibcite{StackOverflowException}{17}
\bibcite{IronPythonPerformance}{18}
\bibcite{CLSCompliant}{19}
\bibcite{AccessingPythonCode}{20}
\bibcite{Stopwatch}{21}
\bibcite{BigO}{22}
\bibcite{Insertionsort}{23}
\bibcite{Mergesort}{24}
\bibcite{ExecutionEngine}{25}
\bibcite{Jit}{26}
\bibcite{PythonSum}{27}
\bibcite{PythonReduce}{28}
\bibcite{PythonSort}{29}
\bibcite{Benchmark}{30}
\bibcite{Benchmark2}{31}
\bibcite{JavaScript.NET}{32}
\bibcite{Jint}{33}
\bibcite{Phalanger}{34}
\bibcite{IronRuby}{35}
\bibcite{Tiobe}{36}
\bibstyle{unsrt}
\setcounter{lastsheet}{56}
\setcounter{lastpage}{46}
